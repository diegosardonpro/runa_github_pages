import os
import re
import json
import requests
import uuid
from supabase import create_client, Client
from src.utils.logger import get_logger
import google.generativeai as genai

# --- CONFIGURACIÓN ---
# v8.0: Versión final con corrección de TypeError y arquitectura de clases
URLS_TABLE = 'urls_para_procesar'
ASSETS_TABLE = 'activos'
METADATA_IMAGES_TABLE = 'metadata_imagenes'
IMAGES_OUTPUT_DIR = 'output_images'

# --- INICIALIZACIÓN DE IA ---
try:
    GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
    if not GEMINI_API_KEY: print("ADVERTENCIA: GEMINI_API_KEY no encontrada.")
    else: genai.configure(api_key=GEMINI_API_KEY)
except Exception as e:
    print(f"Error configurando Gemini: {e}")
    GEMINI_API_KEY = None

# --- INFRAESTRUCTURA COMO CÓDIGO (IaC) ---
SCHEMA_SQL = f"""
CREATE TABLE IF NOT EXISTS public.{ASSETS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    url_original text NOT NULL,
    tipo_activo text NOT NULL,
    estado_curacion text DEFAULT 'pendiente' NOT NULL
);
CREATE TABLE IF NOT EXISTS public.{METADATA_IMAGES_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_id bigint UNIQUE REFERENCES public.{ASSETS_TABLE}(id) ON DELETE CASCADE,
    titulo text,
    descripcion_ia text,
    tags_visuales text,
    resolucion text,
    formato text,
    ruta_local text
);
CREATE TABLE IF NOT EXISTS public.{URLS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    url text NOT NULL UNIQUE,
    estado text DEFAULT 'pendiente' NOT NULL
);
ALTER TABLE public.{ASSETS_TABLE} ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.{METADATA_IMAGES_TABLE} ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.{URLS_TABLE} ENABLE ROW LEVEL SECURITY;
CREATE POLICY \"Permitir inserción anónima en cola de URLs\" ON public.{URLS_TABLE} FOR INSERT TO anon WITH CHECK (true);
"""

# --- FUNCIONES ---
def get_supabase_client(logger):
    url = os.getenv('SUPABASE_URL')
    key = os.getenv('SUPABASE_SERVICE_KEY')
    if not url or not key: raise ValueError("Secretos SUPABASE no encontrados.")
    logger.info("Cliente de Supabase creado.")
    return create_client(url, key)

def setup_database_schema(supabase: Client, logger):
    logger.info("Verificando/creando schema de base de datos...")
    try:
        # Usamos un nombre de función único para evitar colisiones en ejecuciones paralelas.
        function_name = f'setup_schema_{str(uuid.uuid4()).replace("-", "")}'
        
        # Limpiamos el SQL para que sea una sola línea dentro de la función plpgsql.
        clean_schema_sql = ' '.join(SCHEMA_SQL.split())

        # 1. Crear una función SQL temporal que ejecute nuestro bloque de schema.
        #    La sintaxis de diccionario correcta en Python es con llaves simples: {'key': 'value'}.
        sql_function_creation = f'CREATE OR REPLACE FUNCTION {function_name}() RETURNS void AS $ BEGIN {clean_schema_sql} END; $ LANGUAGE plpgsql;'
        supabase.rpc('eval', {'query': sql_function_creation}).execute()

        # 2. Ejecutar la función recién creada.
        supabase.rpc(function_name, {}).execute()

        # 3. Eliminar la función temporal para mantener la base de datos limpia.
        supabase.rpc('eval', {'query': f'DROP FUNCTION {function_name};'}).execute()
        
        logger.info("Schema y políticas de seguridad verificados/creados con éxito.")
    except Exception as e:
        # Manejo de errores para idempotencia: si el schema ya existe, no es un error.
        if "already exists" in str(e) or "already has RLS" in str(e) or "already enabled" in str(e):
            logger.info("La infraestructura base (tablas, RLS) ya existe. No se requieren cambios.")
        else:
            logger.error(f"Error al configurar el schema de la base de datos: {e}", exc_info=True)
            raise

def classify_url_asset(url, logger):
    logger.info(f"Clasificando activo en URL: {url}")
    if not GEMINI_API_KEY: raise ValueError("GEMINI_API_KEY no configurada.")
    try:
        prompt = f"""Analiza el contenido principal de la URL y clasifícalo. Responde únicamente con una palabra: 'imagen', 'texto', 'video' o 'desconocido'. URL: {url}"""
        model = genai.GenerativeModel('gemini-1.5-pro')
        response = model.generate_content(prompt)
        asset_type = response.text.strip().lower()
        logger.info(f"Activo clasificado como: '{asset_type}'")
        return asset_type
    except Exception as e:
        logger.error(f"Error durante la clasificación con IA: {e}", exc_info=True)
        return 'desconocido'

def download_image(image_url, asset_id, logger):
    if not image_url: 
        logger.warning("La IA no devolvió una URL de imagen para descargar.")
        return None
    logger.info(f"Iniciando descarga de imagen: {image_url}")
    try:
        response = requests.get(image_url, stream=True, headers={'User-Agent': 'Mozilla/5.0'})
        response.raise_for_status()
        ext = '.jpg'
        content_type = response.headers.get('content-type')
        if content_type and 'png' in content_type: ext = '.png'
        
        os.makedirs(IMAGES_OUTPUT_DIR, exist_ok=True)
        local_path = os.path.join(IMAGES_OUTPUT_DIR, f"{asset_id}{ext}")
        with open(local_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        logger.info(f"Imagen guardada exitosamente en: {local_path}")
        return local_path
    except Exception as e:
        logger.error(f"Error al descargar la imagen {image_url}: {e}", exc_info=True)
        return None

def process_image_asset(url, supabase, logger):
    logger.info("Iniciando procesamiento para activo de clase 'imagen'...")
    new_asset_id = None
    try:
        prompt = f"""Actúa como curador de activos digitales. Analiza la URL, enfocándote en la imagen principal y su contexto. Devuelve un JSON con: \"titulo\", \"descripcion_ia\", \"tags_visuales\", \"url_imagen_original\". La descripción debe detallar la escena. Los tags deben ser relevantes. URL: {url}"""
        model = genai.GenerativeModel('gemini-1.5-pro')
        response = model.generate_content(prompt)
        metadata = json.loads(response.text.strip().replace("```json", "").replace("```", ""))
        logger.info("Metadatos de imagen extraídos con IA.")

        new_asset_insert = supabase.table(ASSETS_TABLE).insert({"url_original": url, "tipo_activo": "imagen"}).execute()
        new_asset_id = new_asset_insert.data[0]['id']
        logger.info(f"Registro de activo principal creado con ID: {new_asset_id}")

        local_path = download_image(metadata.get('url_imagen_original'), new_asset_id, logger)

        supabase.table(METADATA_IMAGES_TABLE).insert({
            "asset_id": new_asset_id, "titulo": metadata.get('titulo'),
            "descripcion_ia": metadata.get('descripcion_ia'), "tags_visuales": ", ".join(metadata.get('tags_visuales', [])),
            "ruta_local": local_path
        }).execute()
        logger.info("Metadatos de imagen guardados.")

        supabase.table(ASSETS_TABLE).update({"estado_curacion": "completado"}).eq("id", new_asset_id).execute()
        return True
    except Exception as e:
        logger.error(f"Error procesando activo de imagen: {e}", exc_info=True)
        if new_asset_id:
            supabase.table(ASSETS_TABLE).delete().eq('id', new_asset_id).execute()
        return False

def main():
    run_id = str(uuid.uuid4())[:8]
    logger = get_logger(f"curator-{run_id}")
    logger.info(f"--- INICIANDO EJECUCIÓN DEL CURADOR (RUN ID: {run_id}) ---")
    try:
        supabase = get_supabase_client(logger)
        setup_database_schema(supabase, logger)

        response = supabase.table(URLS_TABLE).select('id, url').eq('estado', 'pendiente').limit(1).execute()
        urls_to_process = response.data

        if not urls_to_process: 
            logger.info("No hay nuevas URLs para procesar. Finalizando.")
            return

        for item in urls_to_process:
            url_id, url = item['id'], item['url']
            logger.info(f"--- Procesando URL ID {url_id}: {url} ---")
            supabase.table(URLS_TABLE).update({'estado': 'en_proceso'}).eq('id', url_id).execute()

            asset_type = classify_url_asset(url, logger)
            success = False
            if asset_type in ['imagen', 'texto']:
                success = process_image_asset(url, supabase, logger)
            else:
                logger.warning(f"Clase de activo '{asset_type}' no soportada.")

            final_status = 'completado' if success else 'error'
            supabase.table(URLS_TABLE).update({'estado': final_status}).eq('id', url_id).execute()
            logger.info(f"URL ID {url_id} marcada como '{final_status}'.")

    except Exception as e:
        logger.error(f"Error fatal: {e}", exc_info=True); exit(1)
    finally:
        logger.info(f"--- FINALIZANDO EJECUCIÓN (RUN ID: {run_id}) ---")

if __name__ == "__main__":
    main()
