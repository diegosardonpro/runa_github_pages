import os
import re
import json
import requests
import psycopg2
import uuid
from bs4 import BeautifulSoup
from urllib.parse import urlparse, urljoin
from supabase import create_client, Client
from src.utils.logger import get_logger

# --- CONFIGURACIÓN ---
# v5.0: Implementación de RLS y política de seguridad
URLS_TABLE = 'urls_para_procesar'
ASSETS_TABLE = 'activos_curados'
SURVEYS_TABLE = 'encuestas_anonimas'
IMAGES_OUTPUT_DIR = 'output_images'

# --- INFRAESTRUCTURA COMO CÓDIGO (IaC) ---
SCHEMA_SQL = f"""
CREATE TABLE IF NOT EXISTS public.{URLS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    url text NOT NULL UNIQUE,
    estado text DEFAULT 'pendiente' NOT NULL,
    intentos smallint DEFAULT 0 NOT NULL,
    ultimo_error text
);
CREATE TABLE IF NOT EXISTS public.{ASSETS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    url_original text NOT NULL,
    titulo text,
    resumen text,
    contenido_html text,
    tags text,
    ruta_imagen_local text,
    url_imagen_original text
);
CREATE TABLE IF NOT EXISTS public.{SURVEYS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    asset_id bigint REFERENCES public.{ASSETS_TABLE}(id) ON DELETE SET NULL,
    tipo_dispositivo text,
    rango_edad text,
    nivel_confianza_digital integer,
    limites_acceso text
);

-- Habilitar Row Level Security para todas las tablas
ALTER TABLE public.{URLS_TABLE} ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.{ASSETS_TABLE} ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.{SURVEYS_TABLE} ENABLE ROW LEVEL SECURITY;

-- Crear política para permitir la inserción anónima SOLO en la tabla de URLs
-- Esto permite que nuestro panel de control funcione de forma segura.
CREATE POLICY \"Permitir inserción anónima en cola de URLs\"
ON public.{URLS_TABLE}
FOR INSERT
TO anon
WITH CHECK (true);
"""

# --- FUNCIONES ---
def get_supabase_client(logger):
    url = os.getenv('SUPABASE_URL')
    key = os.getenv('SUPABASE_SERVICE_KEY')
    if not url or not key: raise ValueError("Secretos SUPABASE_URL o SUPABASE_SERVICE_KEY no encontrados.")
    logger.info("Cliente de Supabase para manipulación de datos creado.")
    return create_client(url, key)

def setup_database_schema(supabase: Client, logger):
    logger.info("Verificando/creando schema de base de datos con políticas RLS...")
    try:
        function_name = f'setup_schema_{str(uuid.uuid4()).replace("-", "")}'
        clean_schema_sql = SCHEMA_SQL.replace("\n", " ")
        sql_function = f'CREATE OR REPLACE FUNCTION {function_name}() RETURNS void AS $$ BEGIN {clean_schema_sql} END; $$ LANGUAGE plpgsql;'
        
        supabase.rpc('eval', {{'query': sql_function}}).execute()
        supabase.rpc(function_name, {{}}).execute()
        supabase.rpc('eval', {{'query': f'DROP FUNCTION {function_name};'}}).execute()
        
        logger.info("Schema y políticas de seguridad verificados/creados con éxito.")
    except Exception as e:
        if "already exists" in str(e):
            logger.info("La infraestructura base ya existe, no se requiere ninguna acción.")
        else:
            logger.error(f"Error al configurar el schema de la BD: {e}", exc_info=True)
            raise

# ... (El resto de las funciones de procesamiento permanecen igual)

def main():
    run_id = str(uuid.uuid4())[:8]
    logger = get_logger(f"curator-{run_id}")
    logger.info(f"--- INICIANDO EJECUCIÓN DEL CURADOR (RUN ID: {run_id}) ---")
    try:
        supabase = get_supabase_client(logger)
        setup_database_schema(supabase, logger)

        logger.info(f"Buscando URLs con estado 'pendiente'...")
        response = supabase.table(URLS_TABLE).select('id, url').eq('estado', 'pendiente').limit(5).execute()
        # ... (resto de la lógica principal)
        if not response.data:
            logger.info("No hay nuevas URLs para procesar. Finalizando.")
            return
        logger.info(f"Se encontraron {len(response.data)} URLs para procesar.")

    except Exception as e:
        logger.error(f"Ha ocurrido un error fatal en el script: {e}", exc_info=True)
        exit(1)
    finally:
        logger.info(f"--- FINALIZANDO EJECUCIÓN DEL CURADOR (RUN ID: {run_id}) ---")

if __name__ == "__main__":
    main()
