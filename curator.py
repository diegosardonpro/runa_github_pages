import os
import uuid
from supabase import create_client, Client
from src.utils.logger import get_logger

# --- CONFIGURACIÓN ---
# v2.1: Arquitectura de Conexión Unificada Final
URLS_TABLE = 'urls_para_procesar'
ASSETS_TABLE = 'activos_curados'
SURVEYS_TABLE = 'encuestas_anonimas'

# --- INFRAESTRUCTURA COMO CÓDIGO (IaC) ---
# El SQL ahora se ejecutará a través de una función RPC (Remote Procedure Call) de Supabase
SCHEMA_SQL = f"""
CREATE TABLE IF NOT EXISTS public.{URLS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    url text NOT NULL UNIQUE,
    estado text DEFAULT 'pendiente' NOT NULL,
    intentos smallint DEFAULT 0 NOT NULL,
    ultimo_error text
);
CREATE TABLE IF NOT EXISTS public.{ASSETS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    url_original text NOT NULL,
    titulo text,
    resumen text,
    contenido_html text,
    tags text,
    ruta_imagen_local text,
    url_imagen_original text
);
CREATE TABLE IF NOT EXISTS public.{SURVEYS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    asset_id bigint REFERENCES public.{ASSETS_TABLE}(id) ON DELETE SET NULL,
    tipo_dispositivo text,
    rango_edad text,
    nivel_confianza_digital integer,
    limites_acceso text
);
"""

# --- FUNCIONES ---
def get_supabase_client(logger):
    """Inicializa y devuelve un cliente de Supabase."""
    url = os.getenv('SUPABASE_URL')
    key = os.getenv('SUPABASE_SERVICE_KEY')
    if not url or not key:
        logger.error("Los secretos SUPABASE_URL o SUPABASE_SERVICE_KEY no se encontraron en el entorno.")
        raise ValueError("Secretos SUPABASE_URL o SUPABASE_SERVICE_KEY no encontrados.")
    logger.info("Credenciales de Supabase encontradas. Creando cliente...")
    return create_client(url, key)

def setup_database_schema(supabase: Client, logger):
    """
    Asegura que las tablas existan en la BD usando el cliente de Supabase para ejecutar SQL.
    Es idempotente.
    """
    logger.info("Iniciando configuración de schema de base de datos...")
    try:
        # Usamos .rpc() para ejecutar SQL arbitrario. Creamos una función temporal en la BD para ello.
        # Esto es un método estándar para ejecutar bloques DDL (Data Definition Language)
        function_name = f'setup_schema_{str(uuid.uuid4()).replace("-", "")}'
        
        # Creamos una función en PostgreSQL que ejecuta nuestro DDL y luego la eliminamos
        sql_function = f"""
        CREATE OR REPLACE FUNCTION {function_name}() RETURNS void AS $$
        BEGIN
            {SCHEMA_SQL}
        END;
        $$ LANGUAGE plpgsql;
        """
        
        # Ejecutamos la creación de la función y luego la llamamos
        supabase.rpc('eval', {'query': sql_function}).execute()
        supabase.rpc(function_name, {}).execute()
        
        # Limpiamos la función temporal
        supabase.rpc('eval', {'query': f'DROP FUNCTION {function_name};'}).execute()
        
        logger.info("Schema de la base de datos verificado/creado con éxito.")

    except Exception as e:
        logger.error(f"Error al configurar el schema de la BD: {e}", exc_info=True)
        raise

def main():
    """Función principal que orquesta el script."""
    run_id = str(uuid.uuid4())[:8]
    logger = get_logger(f"curator-{run_id}")

    logger.info(f"--- INICIANDO EJECUCIÓN DEL CURADOR (RUN ID: {run_id}) ---")
    try:
        # 1. Obtener cliente de Supabase (único punto de conexión)
        supabase = get_supabase_client(logger)

        # 2. Asegurar que la infraestructura de la BD esté lista
        setup_database_schema(supabase, logger)

        # 3. Lógica de procesamiento (simulada por ahora)
        logger.info("Buscando URLs con estado 'pendiente'...")
        response = supabase.table(URLS_TABLE).select('id, url').eq('estado', 'pendiente').limit(5).execute()
        urls_to_process = response.data

        if not urls_to_process:
            logger.info("No hay nuevas URLs para procesar. Finalizando ejecución.")
        else:
            logger.info(f"Se encontraron {len(urls_to_process)} URLs para procesar.")
            # ... (Aquí iría el resto de la lógica de procesamiento)

    except Exception as e:
        logger.error(f"Ha ocurrido un error fatal en el script: {e}", exc_info=True)
        exit(1)
    finally:
        logger.info(f"--- FINALIZANDO EJECUCIÓN DEL CURADOR (RUN ID: {run_id}) ---")

if __name__ == "__main__":
    main()