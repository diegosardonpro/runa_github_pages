# src/db_manager.py (v3.1)
import os
from supabase import create_client, Client

# --- CONSTANTES DE TABLAS ---
URLS_TABLE = 'urls_para_procesar'
ASSETS_TABLE = 'activos'
METADATA_ARTICLES_TABLE = 'metadata_articulos'
METADATA_IMAGES_TABLE = 'metadata_imagenes'
EXTRACTED_LINKS_TABLE = 'enlaces_extraidos' # NUEVA TABLA
LOGS_TABLE = 'ejecuciones_log'

# --- INFRAESTRUCTURA COMO CÓDIGO (IaC) v3.1 ---
SCHEMA_SQL = f"""
-- Tabla para la cola de URLs, sin cambios.
CREATE TABLE IF NOT EXISTS public.{URLS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    url text NOT NULL UNIQUE,
    estado text DEFAULT 'pendiente' NOT NULL,
    intentos smallint DEFAULT 0 NOT NULL,
    ultimo_error text
);

-- Tabla central de activos, sin cambios.
CREATE TABLE IF NOT EXISTS public.{ASSETS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    source_url_id bigint REFERENCES public.{URLS_TABLE}(id) ON DELETE SET NULL,
    asset_type text NOT NULL,
    estado_curacion text DEFAULT 'iniciado' NOT NULL,
    created_at timestamptz DEFAULT now() NOT NULL,
    url_original text NOT NULL
);

-- Tabla de metadatos para artículos, sin cambios.
CREATE TABLE IF NOT EXISTS public.{METADATA_ARTICLES_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_id bigint UNIQUE NOT NULL REFERENCES public.{ASSETS_TABLE}(id) ON DELETE CASCADE,
    titulo text,
    resumen text,
    contenido_html text,
    tags text,
    url_imagen_extraida text,
    ruta_imagen_local text
);

-- Tabla de metadatos para imágenes, sin cambios.
CREATE TABLE IF NOT EXISTS public.{METADATA_IMAGES_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_id bigint UNIQUE NOT NULL REFERENCES public.{ASSETS_TABLE}(id) ON DELETE CASCADE,
    titulo_contextual text,
    descripcion_ia text,
    tags_visuales text,
    resolucion text,
    formato text,
    ruta_local text,
    url_original_imagen text
);

-- NUEVA TABLA PARA ENLACES EXTRAÍDOS
CREATE TABLE IF NOT EXISTS public.{EXTRACTED_LINKS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_id bigint NOT NULL REFERENCES public.{ASSETS_TABLE}(id) ON DELETE CASCADE,
    url_enlace text NOT NULL,
    texto_ancla text,
    tipo_enlace text, -- Ej: 'IMAGEN', 'EXTERNO', 'INTERNO'
    created_at timestamptz DEFAULT now() NOT NULL
);

-- Tabla de logs, sin cambios.
CREATE TABLE IF NOT EXISTS public.{LOGS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    run_id text NOT NULL,
    start_time timestamptz DEFAULT now() NOT NULL,
    end_time timestamptz,
    estado text DEFAULT 'iniciado' NOT NULL,
    urls_procesadas integer DEFAULT 0,
    resumen_resultado text
);
"""

# --- FUNCIONES DE GESTIÓN DE BASE DE DATOS ---

def get_supabase_client(logger):
    url = os.getenv('SUPABASE_URL')
    key = os.getenv('SUPABASE_SERVICE_KEY')
    if not url or not key: 
        logger.error("Secretos SUPABASE_URL o SUPABASE_SERVICE_KEY no encontrados.")
        raise ValueError("Secretos de Supabase no encontrados.")
    logger.info("Cliente de Supabase para manipulación de datos creado.")
    return create_client(url, key)

def setup_database_schema(supabase: Client, logger):
    logger.info("Verificando/creando schema de base de datos v3.1...")
    try:
        supabase.rpc('eval', {'query': SCHEMA_SQL}).execute()
        logger.info("Schema de la base de datos verificado/creado con éxito.")
    except Exception as e:
        if "already exists" in str(e): logger.info("Las tablas ya existen.")
        elif "Could not find the function" in str(e): 
            logger.error("La función 'eval' no existe en la BD. Por favor, créala.")
            raise
        else: 
            logger.error(f"Error al configurar el schema: {e}", exc_info=True)
            raise

def create_master_asset(supabase: Client, logger, source_url_id: int, asset_type: str, url_original: str) -> dict | None:
    logger.info(f"Creando registro de activo maestro para URL ID {source_url_id}...")
    try:
        response = supabase.table(ASSETS_TABLE).insert({
            'source_url_id': source_url_id,
            'asset_type': asset_type,
            'url_original': url_original
        }).execute()
        new_asset = response.data[0]
        logger.info(f"Activo maestro creado con éxito. ID: {new_asset['id']}")
        return new_asset
    except Exception as e:
        logger.error(f"Error al crear el activo maestro: {e}", exc_info=True)
        return None

def save_article_metadata(supabase: Client, logger, asset_id: int, metadata: dict):
    logger.info(f"Guardando metadatos de artículo para Asset ID {asset_id}...")
    try:
        metadata['asset_id'] = asset_id
        supabase.table(METADATA_ARTICLES_TABLE).insert(metadata).execute()
        logger.info("Metadatos de artículo guardados con éxito.")
    except Exception as e:
        logger.error(f"Error al guardar metadatos del artículo: {e}", exc_info=True)
        raise

def save_extracted_links(supabase: Client, logger, asset_id: int, links_data: list):
    """Guarda una lista de enlaces extraídos en la base de datos."""
    if not links_data: return
    logger.info(f"Guardando {len(links_data)} enlaces extraídos para Asset ID {asset_id}...")
    try:
        # Añadir el asset_id a cada objeto de enlace
        for link in links_data:
            link['asset_id'] = asset_id
        
        supabase.table(EXTRACTED_LINKS_TABLE).insert(links_data).execute()
        logger.info("Enlaces guardados con éxito.")
    except Exception as e:
        logger.error(f"Error al guardar los enlaces extraídos: {e}", exc_info=True)
        # No relanzamos la excepción para no detener todo el proceso por un fallo en los enlaces

def update_asset_status(supabase: Client, logger, asset_id: int, estado_curacion: str):
    logger.info(f"Actualizando estado del activo {asset_id} a '{estado_curacion}'...")
    try:
        supabase.table(ASSETS_TABLE).update({'estado_curacion': estado_curacion}).eq('id', asset_id).execute()
    except Exception as e:
        logger.error(f"Error al actualizar el estado del activo {asset_id}: {e}", exc_info=True)

def get_pending_urls(supabase: Client, logger, limit: int = 5):
    logger.info(f"Obteniendo hasta {limit} URLs pendientes...")
    try:
        response = supabase.table(URLS_TABLE).select('id, url, intentos').eq('estado', 'pendiente').limit(limit).execute()
        logger.info(f"Se encontraron {len(response.data)} URLs para procesar.")
        return response.data
    except Exception as e:
        logger.error(f"Error al obtener URLs pendientes: {e}", exc_info=True)
        return []

def update_url_status(supabase: Client, logger, url_id: int, estado: str, error: str = None):
    logger.info(f"Actualizando URL ID {url_id} a estado '{estado}'...")
    try:
        update_data = {'estado': estado}
        if error: update_data['ultimo_error'] = error
        supabase.table(URLS_TABLE).update(update_data).eq('id', url_id).execute()
    except Exception as e:
        logger.error(f"Error al actualizar estado para URL ID {url_id}: {e}", exc_info=True)

def log_execution_start(supabase: Client, logger, run_id: str):
    logger.info(f"Registrando inicio de ejecución en BD. Run ID: {run_id}")
    try:
        supabase.table(LOGS_TABLE).insert({'run_id': run_id}).execute()
    except Exception as e:
        logger.error(f"Error al registrar inicio de ejecución: {e}", exc_info=True)

def log_execution_end(supabase: Client, logger, run_id: str, estado: str, urls_procesadas: int, resumen: str):
    logger.info(f"Registrando final de ejecución en BD. Estado: {estado}")
    try:
        supabase.table(LOGS_TABLE).update({
            'end_time': 'now()',
            'estado': estado,
            'urls_procesadas': urls_procesadas,
            'resumen_resultado': resumen
        }).eq('run_id', run_id).execute()
    except Exception as e:
        logger.error(f"Error al registrar final de ejecución: {e}", exc_info=True)
