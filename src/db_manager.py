# src/db_manager.py
import os
import uuid
from supabase import create_client, Client

# --- CONSTANTES ---
URLS_TABLE = 'urls_para_procesar'
ASSETS_TABLE = 'activos_curados'
LOGS_TABLE = 'ejecuciones_log'

# --- INFRAESTRUCTURA COMO CÓDIGO (IaC) ---
SCHEMA_SQL = f"""
CREATE TABLE IF NOT EXISTS public.{URLS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    url text NOT NULL UNIQUE,
    estado text DEFAULT 'pendiente' NOT NULL,
    intentos smallint DEFAULT 0 NOT NULL,
    ultimo_error text
);
CREATE TABLE IF NOT EXISTS public.{ASSETS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    url_original text NOT NULL,
    titulo text,
    resumen text,
    contenido_html text,
    tags text,
    ruta_imagen_local text,
    url_imagen_original text
);
CREATE TABLE IF NOT EXISTS public.{LOGS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    run_id text NOT NULL,
    start_time timestamptz DEFAULT now() NOT NULL,
    end_time timestamptz,
    estado text DEFAULT 'iniciado' NOT NULL,
    urls_procesadas integer DEFAULT 0,
    resumen_resultado text
);
"""

# --- FUNCIONES DE GESTIÓN DE BASE DE DATOS ---

def get_supabase_client(logger):
    """Crea y devuelve un cliente de Supabase."""
    url = os.getenv('SUPABASE_URL')
    key = os.getenv('SUPABASE_SERVICE_KEY')
    if not url or not key: 
        logger.error("Secretos SUPABASE_URL o SUPABASE_SERVICE_KEY no encontrados.")
        raise ValueError("Secretos de Supabase no encontrados.")
    logger.info("Cliente de Supabase para manipulación de datos creado.")
    return create_client(url, key)

def setup_database_schema(supabase: Client, logger):
    """Asegura que el schema de la BD esté configurado, incluyendo la función 'eval'."""
    logger.info("Verificando/creando schema de base de datos...")
    try:
        # Esta es una función que DEBE existir en la base de datos de Supabase.
        # Permite ejecutar bloques de SQL arbitrario.
        supabase.rpc('eval', {'query': SCHEMA_SQL}).execute()
        logger.info("Schema de la base de datos verificado/creado con éxito.")
    except Exception as e:
        if "already exists" in str(e):
            logger.info("Las tablas ya existen, no se requiere ninguna acción.")
        # El error de la función `eval` no existente se captura aquí.
        elif "Could not find the function" in str(e):
            logger.error(f"La función 'eval' no existe en la base de datos. Por favor, créala usando el script de migración proporcionado.")
            raise
        else:
            logger.error(f"Error al configurar el schema de la BD: {e}", exc_info=True)
            raise

def get_pending_urls(supabase: Client, logger, limit: int = 5):
    """Obtiene una lista de URLs pendientes de la base de datos."""
    logger.info(f"Obteniendo hasta {limit} URLs pendientes...")
    try:
        response = supabase.table(URLS_TABLE).select('id, url, intentos').eq('estado', 'pendiente').limit(limit).execute()
        logger.info(f"Se encontraron {len(response.data)} URLs para procesar.")
        return response.data
    except Exception as e:
        logger.error(f"Error al obtener URLs pendientes: {e}", exc_info=True)
        return []

def update_url_status(supabase: Client, logger, url_id: int, estado: str, error: str = None):
    """Actualiza el estado de una URL en la base de datos."""
    logger.info(f"Actualizando URL ID {url_id} a estado '{estado}'...")
    try:
        update_data = {'estado': estado}
        if error:
            update_data['ultimo_error'] = error
        
        # Incrementar el contador de intentos
        # Esta es una operación más compleja que requiere una función RPC o una lógica de lectura/escritura
        # Por simplicidad, lo mantenemos así por ahora.
        supabase.table(URLS_TABLE).update(update_data).eq('id', url_id).execute()
    except Exception as e:
        logger.error(f"Error al actualizar estado para URL ID {url_id}: {e}", exc_info=True)

def save_curated_asset(supabase: Client, logger, asset_data: dict):
    """Guarda un nuevo activo curado en la base de datos."""
    logger.info(f"Guardando activo curado para URL: {asset_data.get('url_original')}")
    try:
        response = supabase.table(ASSETS_TABLE).insert(asset_data).execute()
        logger.info(f"Activo guardado con éxito. ID: {response.data[0]['id']}")
        return response.data[0]
    except Exception as e:
        logger.error(f"Error al guardar el activo curado: {e}", exc_info=True)
        return None

def log_execution_start(supabase: Client, logger, run_id: str):
    """Registra el inicio de una ejecución del workflow."""
    logger.info(f"Registrando inicio de ejecución en BD. Run ID: {run_id}")
    try:
        supabase.table(LOGS_TABLE).insert({'run_id': run_id}).execute()
    except Exception as e:
        logger.error(f"Error al registrar inicio de ejecución: {e}", exc_info=True)

def log_execution_end(supabase: Client, logger, run_id: str, estado: str, urls_procesadas: int, resumen: str):
    """Registra el final de una ejecución del workflow."""
    logger.info(f"Registrando final de ejecución en BD. Estado: {estado}")
    try:
        supabase.table(LOGS_TABLE).update({
            'end_time': 'now()',
            'estado': estado,
            'urls_procesadas': urls_procesadas,
            'resumen_resultado': resumen
        }).eq('run_id', run_id).execute()
    except Exception as e:
        logger.error(f"Error al registrar final de ejecución: {e}", exc_info=True)
