# src/db_manager.py (v3.2 - Visión)
import os
from supabase import create_client, Client

# --- CONSTANTES DE TABLAS ---
URLS_TABLE = 'urls_para_procesar'
ASSETS_TABLE = 'activos'
METADATA_ARTICLES_TABLE = 'metadata_articulos'
METADATA_IMAGES_TABLE = 'metadata_imagenes' # Rediseñada para el análisis de visión
LOGS_TABLE = 'ejecuciones_log'

# --- INFRAESTRUCTURA COMO CÓDIGO (IaC) v3.2 ---
SCHEMA_SQL = f"""
CREATE TABLE IF NOT EXISTS public.{URLS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    url text NOT NULL UNIQUE,
    estado text DEFAULT 'pendiente' NOT NULL,
    intentos smallint DEFAULT 0 NOT NULL,
    ultimo_error text
);

CREATE TABLE IF NOT EXISTS public.{ASSETS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    source_url_id bigint REFERENCES public.{URLS_TABLE}(id) ON DELETE SET NULL,
    asset_type text NOT NULL,
    estado_curacion text DEFAULT 'iniciado' NOT NULL,
    created_at timestamptz DEFAULT now() NOT NULL,
    url_original text NOT NULL
);

-- Se eliminan los campos de imagen de esta tabla
CREATE TABLE IF NOT EXISTS public.{METADATA_ARTICLES_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_id bigint UNIQUE NOT NULL REFERENCES public.{ASSETS_TABLE}(id) ON DELETE CASCADE,
    titulo text,
    resumen text,
    contenido_html text,
    tags text
);

-- Rediseñada para guardar los datos de cada imagen analizada por la IA de Visión
CREATE TABLE IF NOT EXISTS public.{METADATA_IMAGES_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_id bigint NOT NULL REFERENCES public.{ASSETS_TABLE}(id) ON DELETE CASCADE, -- Ya no es UNIQUE
    url_original_imagen text NOT NULL,
    ruta_local text,
    tags_visuales_ia text,
    descripcion_ia text,
    orden_aparicion smallint -- Para saber en qué orden aparece en el artículo
);

CREATE TABLE IF NOT EXISTS public.{LOGS_TABLE} (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    run_id text NOT NULL,
    start_time timestamptz DEFAULT now() NOT NULL,
    end_time timestamptz,
    estado text DEFAULT 'iniciado' NOT NULL,
    urls_procesadas integer DEFAULT 0,
    resumen_resultado text
);
"""

# --- FUNCIONES DE GESTIÓN DE BASE DE DATOS ---

def get_supabase_client(logger):
    url = os.getenv('SUPABASE_URL')
    key = os.getenv('SUPABASE_SERVICE_KEY')
    if not url or not key: 
        logger.error("Secretos SUPABASE_URL o SUPABASE_SERVICE_KEY no encontrados.")
        raise ValueError("Secretos de Supabase no encontrados.")
    logger.info("Cliente de Supabase para manipulación de datos creado.")
    return create_client(url, key)

def setup_database_schema(supabase: Client, logger):
    logger.info("Verificando/creando schema de base de datos v3.2.2...")
    try:
        # 1. Ejecutar el schema principal con "IF NOT EXISTS"
        supabase.rpc('eval', {'query': SCHEMA_SQL}).execute()
        logger.info("Schema base (tablas, etc.) verificado/creado con éxito.")

        # 2. Migración/Corrección: Asegurar que el schema de la BD coincida con el del código.
        logger.info(f"Asegurando estructura de la tabla {METADATA_IMAGES_TABLE}...")
        migration_sqls = [
            # Añadir columnas si no existen
            f"ALTER TABLE public.{METADATA_IMAGES_TABLE} ADD COLUMN IF NOT EXISTS tags_visuales_ia text;",
            f"ALTER TABLE public.{METADATA_IMAGES_TABLE} ADD COLUMN IF NOT EXISTS descripcion_ia text;",
            f"ALTER TABLE public.{METADATA_IMAGES_TABLE} ADD COLUMN IF NOT EXISTS orden_aparicion smallint;",
            # Eliminar la restricción UNIQUE obsoleta de asset_id si existe
            f"ALTER TABLE public.{METADATA_IMAGES_TABLE} DROP CONSTRAINT IF EXISTS metadata_imagenes_asset_id_key;"
        ]
        for sql in migration_sqls:
            supabase.rpc('eval', {'query': sql}).execute()
        logger.info(f"Toda la estructura para el schema v3.2.2 ha sido asegurada.")

    except Exception as e:
        if "already exists" in str(e): logger.info("Las tablas ya existen.")
        elif "Could not find the function" in str(e): 
            logger.error("La función 'eval' no existe en la BD. Por favor, créala.")
            raise
        else: 
            logger.error(f"Error al configurar el schema: {e}", exc_info=True)
            raise

def create_master_asset(supabase: Client, logger, source_url_id: int, asset_type: str, url_original: str) -> dict | None:
    logger.info(f"Creando registro de activo maestro para URL ID {source_url_id}...")
    try:
        response = supabase.table(ASSETS_TABLE).insert({
            'source_url_id': source_url_id,
            'asset_type': asset_type,
            'url_original': url_original
        }).execute()
        return response.data[0]
    except Exception as e:
        logger.error(f"Error al crear el activo maestro: {e}", exc_info=True)
        return None

def save_article_metadata(supabase: Client, logger, asset_id: int, metadata: dict):
    logger.info(f"Guardando metadatos de artículo para Asset ID {asset_id}...")
    try:
        metadata['asset_id'] = asset_id
        supabase.table(METADATA_ARTICLES_TABLE).insert(metadata).execute()
    except Exception as e:
        logger.error(f"Error al guardar metadatos del artículo: {e}", exc_info=True)
        raise

def save_image_metadata(supabase: Client, logger, image_data: dict):
    """Guarda los metadatos de una imagen analizada por la IA de visión."""
    logger.info(f"Guardando metadatos de imagen para Asset ID {image_data.get('asset_id')}...")
    try:
        supabase.table(METADATA_IMAGES_TABLE).insert(image_data).execute()
    except Exception as e:
        logger.error(f"Error al guardar metadatos de la imagen: {e}", exc_info=True)

def update_asset_status(supabase: Client, logger, asset_id: int, estado_curacion: str):
    logger.info(f"Actualizando estado del activo {asset_id} a '{estado_curacion}'...")
    try:
        supabase.table(ASSETS_TABLE).update({'estado_curacion': estado_curacion}).eq('id', asset_id).execute()
    except Exception as e:
        logger.error(f"Error al actualizar el estado del activo {asset_id}: {e}", exc_info=True)

def get_pending_urls(supabase: Client, logger, limit: int = 5):
    logger.info(f"Obteniendo hasta {limit} URLs pendientes...")
    try:
        response = supabase.table(URLS_TABLE).select('id, url, intentos').eq('estado', 'pendiente').limit(limit).execute()
        return response.data
    except Exception as e:
        logger.error(f"Error al obtener URLs pendientes: {e}", exc_info=True)
        return []

def add_url_if_not_exists(supabase: Client, logger, url: str):
    """
    Inserta una nueva URL si no existe, o la encuentra si ya existe.
    Siempre devuelve el registro completo de la URL.
    """
    try:
        # Upsert con returning='representation' para que devuelva el registro.
        response = supabase.table(URLS_TABLE).upsert({
            'url': url,
            'estado': 'pendiente'
        }, on_conflict='url', returning='representation').execute()
        return response
    except Exception as e:
        logger.error(f"Error al hacer upsert con la URL {url}: {e}", exc_info=True)
        return None


def update_url_status(supabase: Client, logger, url_id: int, estado: str, error: str = None):
    logger.info(f"Actualizando URL ID {url_id} a estado '{estado}'...")
    try:
        update_data = {'estado': estado}
        if error: update_data['ultimo_error'] = error
        supabase.table(URLS_TABLE).update(update_data).eq('id', url_id).execute()
    except Exception as e:
        logger.error(f"Error al actualizar estado para URL ID {url_id}: {e}", exc_info=True)

def log_execution_start(supabase: Client, logger, run_id: str):
    logger.info(f"Registrando inicio de ejecución en BD. Run ID: {run_id}")
    try:
        supabase.table(LOGS_TABLE).insert({'run_id': run_id}).execute()
    except Exception as e:
        logger.error(f"Error al registrar inicio de ejecución: {e}", exc_info=True)

def log_execution_end(supabase: Client, logger, run_id: str, estado: str, urls_procesadas: int, resumen: str):
    logger.info(f"Registrando final de ejecución en BD. Estado: {estado}")
    try:
        supabase.table(LOGS_TABLE).update({
            'end_time': 'now()',
            'estado': estado,
            'urls_procesadas': urls_procesadas,
            'resumen_resultado': resumen
        }).eq('run_id', run_id).execute()
    except Exception as e:
        logger.error(f"Error al registrar final de ejecución: {e}", exc_info=True)